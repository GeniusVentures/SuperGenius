

#ifndef SUPERGENIUS_SRC_PRIMITIVES_DIGEST_HPP
#define SUPERGENIUS_SRC_PRIMITIVES_DIGEST_HPP

#include <boost/variant.hpp>
#include "base/buffer.hpp"

namespace sgns::primitives {
  
  /// Verification engine unique ID.
  using VerificationEngineId = base::Blob<4>;


  inline const auto kProductionEngineId =
      VerificationEngineId::fromString("BABE").value();

  inline const auto kFinalityEngineId =
      VerificationEngineId::fromString("FRNK").value();

  /// System digest item that contains the root of changes trie at given
  /// block. It is created for every block iff runtime supports changes
  /// trie creation.
  using ChangesTrieRoot = base::Hash256;

  namespace detail {
    struct DigestItemCommon {
      VerificationEngineId verification_engine_id;
      base::Buffer data;

      bool operator==(const DigestItemCommon &rhs) const {
        return verification_engine_id == rhs.verification_engine_id
               && data == rhs.data;
      }

      bool operator!=(const DigestItemCommon &rhs) const {
        return !operator==(rhs);
      }
    };
  }  // namespace detail

  /// A pre-runtime digest.
  ///
  /// These are messages from the verification engine to the runtime, although
  /// the verification engine can (and should) read them itself to avoid
  /// code and state duplication. It is erroneous for a runtime to produce
  /// these, but this is not (yet) checked.
  struct PreRuntime : public detail::DigestItemCommon {};

  /// A message from the runtime to the verification engine. This should *never*
  /// be generated by the native code of any verification engine, but this is not
  /// checked (yet).
  struct Verification : public detail::DigestItemCommon {};

  /// Put a Seal on it. This is only used by native code, and is never seen
  /// by runtimes.
  struct Seal : public detail::DigestItemCommon {};

  template <class Stream,
            typename = std::enable_if_t<Stream::is_encoder_stream>>
  Stream &operator<<(Stream &s, const detail::DigestItemCommon &dic) {
    return s << dic.verification_engine_id << dic.data;
  }

  template <class Stream,
            typename = std::enable_if_t<Stream::is_decoder_stream>>
  Stream &operator>>(Stream &s, detail::DigestItemCommon &dic) {
    return s >> dic.verification_engine_id >> dic.data;
  }

  /// Some other thing. Unsupported and experimental.
  using Other = base::Buffer;
  /// Digest item that is able to encode/decode 'system' digest items and
  /// provide opaque access to other items.
  /// Note: order of types in variant matters. Should match type ids from here:
  using DigestItem = boost::variant<
      Other,            // = 0
      uint32_t,         // = 1 (fake type, should never be used in digest)
      ChangesTrieRoot,  // = 2
      std::string,      // = 3 (fake type, should never be used in digest)
      Verification,     // = 4
      Seal,             // = 5
      PreRuntime>;      // = 6

  /**
   * Digest is an implementation- and usage-defined entity, for example,
   * information, needed to verify the block
   */
  using Digest = std::vector<DigestItem>;
}  // namespace sgns::primitives

#endif  // SUPERGENIUS_SRC_PRIMITIVES_DIGEST_HPP
