#ifndef SUPERGENIUS_SRC_PRIMITIVES_DIGEST_HPP
#define SUPERGENIUS_SRC_PRIMITIVES_DIGEST_HPP

#include <boost/variant.hpp>
#include "base/buffer.hpp"
#include "base/unused.hpp"
#include "primitives/scheduled_change.hpp"

namespace sgns::primitives {
  /// Verification engine unique ID.
  using VerificationEngineId = base::Blob<4>;


  inline const auto kProductionEngineId =
      VerificationEngineId::fromString("BABE").value();

  inline const auto kFinalityEngineId =
      VerificationEngineId::fromString("FRNK").value();

  /// System digest item that contains the root of changes trie at given
  /// block. It is created for every block iff runtime supports changes
  /// trie creation.
  using ChangesTrieRoot = base::Hash256;

  namespace detail {
    struct DigestItemCommon {
      VerificationEngineId verification_engine_id;
      base::Buffer data;

      bool operator==(const DigestItemCommon &rhs) const {
        return verification_engine_id == rhs.verification_engine_id
               && data == rhs.data;
      }

      bool operator!=(const DigestItemCommon &rhs) const {
        return !operator==(rhs);
      }
    };
  }  // namespace detail

  /// A pre-runtime digest.
  ///
  /// These are messages from the verification engine to the runtime, although
  /// the verification engine can (and should) read them itself to avoid
  /// code and state duplication. It is erroneous for a runtime to produce
  /// these, but this is not (yet) checked.
  struct PreRuntime : public detail::DigestItemCommon {};

  /// A message from the runtime to the verification engine. This should *never*
  /// be generated by the native code of any verification engine, but this is not
  /// checked (yet).
  struct Verification : public detail::DigestItemCommon {
    boost::variant<Unused<0>,
                   ScheduledChange,  // 1: (Auth C; N delay)
                   ForcedChange,     // 2: (Auth C; N delay)
                   OnDisabled,       // 3: Auth ID
                   Pause,            // 4: N delay
                   Resume>           // 5: N delay
        payload = Unused<0>{};

    Verification() = default;

    template <class A,
              typename = std::enable_if_t<!std::is_same_v<A, Verification>, void>>
    Verification(A &&a) : payload(std::forward<A>(a)){};

    template <class A,
              typename = std::enable_if_t<!std::is_same_v<A, Verification>, void>>
    Verification(const A &a) : payload(a){};
  };

  /// Put a Seal on it. This is only used by native code, and is never seen
  /// by runtimes.
  struct Seal : public detail::DigestItemCommon {};

  template <class Stream,
            typename = std::enable_if_t<Stream::is_encoder_stream>>
  Stream &operator<<(Stream &s, const detail::DigestItemCommon &dic) {
    return s << dic.verification_engine_id << dic.data;
  }

  template <class Stream,
            typename = std::enable_if_t<Stream::is_decoder_stream>>
  Stream &operator>>(Stream &s, detail::DigestItemCommon &dic) {
    return s >> dic.verification_engine_id >> dic.data;
  }

  /// Digest item that is able to encode/decode 'system' digest items and
  /// provide opaque access to other items.
  /// Note: order of types in variant matters. Should match type ids from here:
  using DigestItem = boost::variant<Unused<0>,        // 0
                                    Unused<1>,        // 1
                                    ChangesTrieRoot,  // 2
                                    Unused<3>,        // 3
                                    Verification,     // 4
                                    Seal,             // 5
                                    PreRuntime>;      // 6

  /**
   * Digest is an implementation- and usage-defined entity, for example,
   * information, needed to verify the block
   */
  using Digest = std::vector<DigestItem>;
}  // namespace sgns::primitives

#endif  // SUPERGENIUS_SRC_PRIMITIVES_DIGEST_HPP
