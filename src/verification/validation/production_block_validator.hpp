

#ifndef SUPERGENIUS_PRODUCTION_BLOCK_VALIDATOR_HPP
#define SUPERGENIUS_PRODUCTION_BLOCK_VALIDATOR_HPP

#include <memory>
#include <unordered_map>
#include <unordered_set>
#include <utility>

#include "blockchain/block_tree.hpp"
#include "base/logger.hpp"
#include "verification/production/types/production_block_header.hpp"
#include "verification/production/types/seal.hpp"
#include "verification/validation/block_validator.hpp"
#include "crypto/hasher.hpp"
#include "crypto/vrf_provider.hpp"
#include "primitives/authority.hpp"
#include "runtime/tagged_transaction_queue.hpp"

namespace sgns::crypto {
  class SR25519Provider;
}

namespace sgns::verification {
  /**
   * Validation of blocks in BABE system. Based on the algorithm described here:
  */
  class ProductionBlockValidator : public BlockValidator {
   public:
    ~ProductionBlockValidator() override = default;

    /**
     * Create an instance of ProductionBlockValidator
     * @param block_tree to be used by this instance
     * @param tx_queue to validate the extrinsics
     * @param hasher to take hashes
     * @param vrf_provider for VRF-specific operations
     */
    ProductionBlockValidator(
        std::shared_ptr<blockchain::BlockTree> block_tree,
        std::shared_ptr<runtime::TaggedTransactionQueue> tx_queue,
        std::shared_ptr<crypto::Hasher> hasher,
        std::shared_ptr<crypto::VRFProvider> vrf_provider,
        std::shared_ptr<crypto::SR25519Provider> sr25519_provider);

    enum class ValidationError {
      NO_AUTHORITIES = 1,
      INVALID_SIGNATURE,
      INVALID_VRF,
      TWO_BLOCKS_IN_SLOT,
      INVALID_TRANSACTIONS
    };

    outcome::result<void> validateBlock(
        const primitives::Block &block,
        const primitives::AuthorityId &authority_id,
        const Threshold &threshold,
        const Randomness &randomness) const override;

    outcome::result<void> validateHeader(
        const primitives::BlockHeader &header,
        const primitives::AuthorityId &authority_id,
        const Threshold &threshold,
        const Randomness &randomness) const override;

   private:
    /**
     * Verify that block is signed by valid signature
     * @param header Header to be checked
     * @param production_header ProductionBlockHeader corresponding to (fetched from) header
     * @param seal Seal corresponding to (fetched from) header
     * @param public_key public key that corresponds to the authority by
     * authority index
     * @return true if signature is valid, false otherwise
     */
    bool verifySignature(const primitives::BlockHeader &header,
                         const ProductionBlockHeader &production_header,
                         const Seal &seal,
                         const primitives::SessionKey &public_key) const;

    /**
     * Verify that vrf value contained in production_header is less than threshold and
     * was generated by the creator of the block
     * @param production_header ProductionBlockHeader corresponding to (fetched from) header
     * @param public_key Public key of creator of the block
     * @param threshold threshold value for that epoch
     * @param randomness randomness for that epoch
     * @return true if vrf is valid, false otherwise
     */
    bool verifyVRF(const ProductionBlockHeader &production_header,
                   const primitives::SessionKey &public_key,
                   const Threshold &threshold,
                   const Randomness &randomness) const;

    /**
     * Check, if the peer has produced a block in this slot and memorize, if the
     * peer hasn't
     * @param peer to be checked
     * @return true, if the peer has not produced any blocks in this slot, false
     * otherwise
     */
    bool verifyProducer(const ProductionBlockHeader &production_header) const;

    /**
     * Check, if all transactions in the block are valid
     * @return true, if all transactions have passed verification, false
     * otherwise
     */
    bool verifyTransactions(const primitives::BlockBody &block_body) const;

    std::shared_ptr<blockchain::BlockTree> block_tree_;
    mutable std::unordered_map<ProductionSlotNumber,
                               std::unordered_set<primitives::AuthorityIndex>>
        blocks_producers_;

    std::shared_ptr<runtime::TaggedTransactionQueue> tx_queue_;

    std::shared_ptr<crypto::Hasher> hasher_;

    std::shared_ptr<crypto::VRFProvider> vrf_provider_;
    std::shared_ptr<crypto::SR25519Provider> sr25519_provider_;

    base::Logger log_;
  };
}  // namespace sgns::verification

OUTCOME_HPP_DECLARE_ERROR_2(sgns::verification,
                          ProductionBlockValidator::ValidationError)

#endif  // SUPERGENIUS_PRODUCTION_BLOCK_VALIDATOR_HPP
